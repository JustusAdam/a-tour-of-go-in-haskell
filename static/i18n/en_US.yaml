test:
  message: Hello

goroutines:
  first: "Haskell has a lightweight thread feature as in Go."
  inter: "starts a new lightweight thread running"
  overviewPreAsync:
    '<code>async :: IO a -> Async a</code> is not a special syntax, but a just function.
    The function <code>async</code> is provided from the '
  overviewPostAsync:
    ' package'
  detailPreBase:
    'Haskell has several tools for communication between different threads.
    Basic tools are provided from the standard '
  detailPostBase:
    ' package.
    Just like Go, we can use channel. (See the next page.)'
  note: ""

channels:
  first:
    'Channel is one-directional tube to flow values.
    Values are appended to the end of channel, then taken from the top of channel.'
  writeChan: "Append v to the end of channel ch"
  readChan: "Take one from the top of channel ch"
  postRW: ""
  preNewChan: "Channel instance must be built before use."
  postNewChan:
    'Different threads can use one channel simultaneously.
    If a thread try to <code>readChan</code> to empty channel,
    the thread does not raise error, but just be blocked until new value.
    By the behavior, we can fall threads in line with each other.'
  example:
    'The example code makes lightweight threads calculate sum of <code>Int</code> lists.
    The main thread waits results from lightweight threads, then use them.'
  stm:
    ' package provides another implimentation of channel.
    STM will be introduced later.'

bufferedChannels:
  first: ' package introduces a size-bounded channel.'
  post:
    'The reason why we bound channel size is that
    the production rate of a channel upstream should not be over the consumption rate of a channel downstream.'
  stm: ' package also have bounded channel: <code>TBQueue</code>'

rangeAndClose:
  first:
    'Altough Haskell does not have things just like <code>range</code> and <code>close</code> of Go,
    they can easily be composed if you need.'
  range:
    '<code>range</code> clause on for statement of Go is useful to iterate channel values like array.
    Because <code>getChanContents :: Chan a -> IO [a]</code> converts channel to list,
    it works similar to <code>range</code>.'
  close:
    'A built-in function <code>close</code> of Go marks that no more values will be sent to a channel.
    <code>Maybe</code> will be used to imitate <code>close</code>.
    We send <code>Nothing</code> as the last value.
    However this is just a simple solution.
    Note that it does not cause errors if extra values is sent to a closed channel.'
  list:
    'By the way, the sample code on the right side can be written by list of Haskell.
    Refer to the list version below.'
