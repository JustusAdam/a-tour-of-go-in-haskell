test:
  message: Hello

index:
  first: ""

goroutines:
  first: "Haskell has a lightweight thread feature as in Go."
  inter: "starts a new lightweight thread running"
  overviewPreAsync:
    '<code>async :: IO a -> Async a</code> is not a special syntax, but a just function.
    The function <code>async</code> is provided from the '
  overviewPostAsync:
    ' package'
  detailPreBase:
    'Haskell has several tools for communication between different threads.
    Basic tools are provided from the standard '
  detailPostBase:
    ' package.
    Just like Go, we can use channel. (See the next page.)'
  note: ""

channels:
  first:
    'Channel is one-directional tube to flow values.
    Values are appended to the end of channel, then taken from the top of channel.'
  writeChan: "Append v to the end of channel ch"
  readChan: "Take one from the top of channel ch"
  postRW: ""
  preNewChan: "Channel instance must be built before use."
  postNewChan:
    'Different threads can share one channel.
    If a thread try to <code>readChan</code> to empty channel,
    the thread does not raise error, but just be blocked until new value.
    By the behavior, we can fall threads in line with each other.'
  example:
    'The example code makes lightweight threads calculate sum of <code>Int</code> lists.
    The main thread waits results from lightweight threads, then use them.'
  stm:
    ' package provides another implimentation of channel.
    STM will be introduced later.
    Now keep in mind only that you should use <code>atomically</code> to run stm computations.'

bufferedChannels:
  first: ' package introduces a size-bounded channel.'
  post:
    'To <code>writeChan</code> to a full channel is blocked.
    The reason why we bound channel size is that
    the production rate of a channel upstream should not be over the consumption rate of a channel downstream.'
  stm: ' package also have bounded channel: <code>TBQueue</code>'

rangeAndClose:
  first:
    'Although Haskell does not have things just like <code>range</code> and <code>close</code> of Go,
    they can easily be composed if you need.'
  range:
    '<code>range</code> clause on for statement of Go is useful to iterate channel values like array.
    Because <code>getChanContents :: Chan a -> IO [a]</code> converts channel to list,
    it works similar to <code>range</code>.'
  close:
    'A built-in function <code>close</code> of Go marks that no more values will be sent to a channel.
    <code>Maybe</code> will be used to imitate <code>close</code>.
    We send <code>Nothing</code> as the last value.
    However this is just a simple solution.
    Note that it does not cause errors if extra values is sent to a closed channel.'
  list:
    'By the way, the sample code on the right side can be written by list of Haskell.
    Refer to the list version below.'

select:
  first:
    'Although Haskell does not have a thing just like <code>select</code>,
    it can easily be composed if you need.'
  preStm:
    '<code>select</code> in Go chooses a available one of multiple communication operations. The '
  postStm:
    ' package provides a function <code>orElse :: STM a -> STM a -> STM a</code> which chooses a available one of two stm operations.
    <code>fold</code> functions in Haskell make two-args function to list function.
    Note that in a case that multiple operations are available, this implimentation chooses a available operation in order from the beginning.
    (Go <code>select</code> chooses randomly for that case.)
    And, all stm operations of the list should be same type.'
  preMsum:
    'Actually <code>STM</code> is a instance of <code>MonadPlus</code>.
    So we can implement <code>select</code> as below.'
  postMsum:
    'Because the <code>MonadPlus</code> instance is implemented using <code>orElse</code>,
    we can write <code>select</code> in this way.
    Note that the <code>orElse</code> implementation of the <code>MonadPlus</code> instance is not documented explicitly.'

defaultSelection:
  first:
    'The <code>select</code> of Go can include a default case when there is no other available communication.
    Default case make <code>select</code> non-blocking.'
  preCode:
    'In our Haskell-version <code>select</code>, just <code>return</code> at the last of the list.'
  tickAfter:
    'The sample code on the right side also implements functions similar to <code>time.Tick</code> and <code>time.After</code> of Go.'

equivalentBinaryTrees1:
  first:
    'Different binary trees storing same elements can be different shapes.
    Following two binary trees have same elements.'
  function:
    'Using concurrency techniques we have seen, make a function to check whether two binary trees store same elements.'
  tree:
    'Here is the abstract data type of binary trees.'
  next:
    'See the next page.'

equivalentBinaryTrees2:
  implementWalk: ""
  testWalk: ""
  newTree: ""
  printTree: ""
  implementSame: ""
  testSame: ""
  link: ""
  pure: ""

syncMutex:
  first:
    'Channel is a useful tool for communication between lightweight threads.
    But there are other kind of communications which are impossible (or hard) to be solved by channel.
    For example, a case that threads share a variable and modify it without conflicts.'
  mutex:
    'Go provides traditional Mutex for the problem.
    We can use <code>TVar</code> in the STM toolbox on Haskell.
    <code>TVar</code> solve the problem directly compared to Mutex.
    The usage is similar to <code>TQueue</code>.'
  sample:
    'The sample code on the right side composes a counter which is safely modified by multiple threads by using <code>TVar</code>.
    Because the <code>atomically</code> of STM makes a <strong>transaction</strong> (indivisible section),
    modifying counter do not cause conflicts.'

webCrawler:
  first: ""
  crawl: ""
  hint: ""
  link: ""
