test:
  message: こんにちは

goroutines:
  first: "Haskell は Go と同じく軽量スレッドの機能を持っています。"
  inter: "これは新しい軽量スレッドを作り、その中で次の処理を起動します。"
  overviewPreAsync:
    '<code>async :: IO a -> Async a</code> は何か特殊な構文というわけではなく通常の関数です。
    <code>async</code> 関数は '
  overviewPostAsync:
    ' パッケージで提供されています。'
  detailPreBase:
    'Haskell には複数のスレッドの間で値をやりとりするための道具がいくつかあります。
    基本的な道具は標準の '
  detailPostBase:
    ' パッケージによって提供されています。
    ちょうど Go のように、チャネルを使うこともできます(次のページ)。'
  note: ""

channels:
  first:
    'チャネルは値が一方向にだけ流れる管です。
    値はチャネルの末尾に追加され、先頭から取り出さます。'
  writeChan: "v をチャネル ch の末尾に追加する"
  readChan: "チャネル ch の先頭から値を取り出す"
  postRW: ""
  preNewChan: "チャネルは使う前に作っておく必要があります。"
  postNewChan:
    'ひとつのチャネルへの書き込みと読み出しは異なる複数のスレッドから行うことができます。
    もしチャネルが空のときに <code>readChan</code> しようとしても、
    それはエラーにはならず、単に値が来るまで停止(ブロック)します。
    この挙動によって複数のスレッドの歩調を合わせることができます。'
  example:
    'サンプルコードは軽量スレッドに <code>Int</code> リストの合計を計算させています。
    軽量スレッドの計算結果が出揃うのを待ち、メインスレッドでそれらを使います。'
  stm:
    ' パッケージは別のチャネル実装を提供します。stmについては後ほど説明します。'

bufferedChannels:
  first: " パッケージでサイズを制限したチャネルを作ることができます。"
  post:
    '満杯のチャネルへの <code>writeChan</code> はブロックされます。
    チャネルのサイズを制限することで、
    チャネルの下流のスレッドによる消費が追い付かない速度で上流のスレッドが値を作り出すのを抑止できます。'
  stm: ' パッケージにも <code>TBQueue</code> という制限付きチャネルがあります。'
