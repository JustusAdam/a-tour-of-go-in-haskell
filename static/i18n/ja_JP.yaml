test:
  message: こんにちは

goroutines:
  first: "Haskell は Go と同じく軽量スレッドの機能を持っています。"
  inter: "これは新しい軽量スレッドを作り、その中で次の処理を起動します。"
  overviewPreAsync:
    '<code>async :: IO a -> Async a</code> は何か特殊な構文というわけではなく通常の関数です。
    <code>async</code> 関数は '
  overviewPostAsync:
    ' パッケージで提供されています。'
  detailPreBase:
    'Haskell には複数のスレッドの間で値をやりとりするための道具がいくつかあります。
    基本的な道具は標準の '
  detailPostBase:
    ' パッケージによって提供されています。
    ちょうど Go のように、チャネルを使うこともできます(次のページ)。'
  note: ""

channels:
  first:
    'チャネルは値が一方向にだけ流れる管です。
    値はチャネルの末尾に追加され、先頭から取り出さます。'
  writeChan: "v をチャネル ch の末尾に追加する"
  readChan: "チャネル ch の先頭から値を取り出す"
  postRW: ""
  preNewChan: "チャネルは使う前に作っておく必要があります。"
  postNewChan:
    'ひとつのチャネルへの書き込みと読み出しは異なる複数のスレッドから行うことができます。
    もしチャネルが空のときに <code>readChan</code> しようとしても、
    それはエラーにはならず、単に値が来るまで停止(ブロック)します。
    この挙動によって複数のスレッドの歩調を合わせることができます。'
  example:
    'サンプルコードは軽量スレッドに <code>Int</code> リストの合計を計算させています。
    軽量スレッドの計算結果が出揃うのを待ち、メインスレッドでそれらを使います。'
  stm:
    ' パッケージは別のチャネル実装を提供します。stmについては後ほど説明します。'

bufferedChannels:
  first: " パッケージでサイズを制限したチャネルを作ることができます。"
  post:
    '満杯のチャネルへの <code>writeChan</code> はブロックされます。
    チャネルのサイズを制限することで、
    チャネルの下流のスレッドによる消費が追い付かない速度で上流のスレッドが値を作り出すのを抑止できます。'
  stm: ' パッケージにも <code>TBQueue</code> という制限付きチャネルがあります。'

rangeAndClose:
  first:
    'Go の <code>range</code> と <code>close</code> に直接相当するものは
    Haskell にはありませんが、必要であれば簡単に用意することができます。'
  range:
    'Go の for 式とともに使う <code>range</code> 句は、
    チャネルの要素を(ちょうど配列のように)反復処理したいときに役立ちます。
    Haskell の <code>getChanContents :: Chan a -> IO [a]</code>
    はチャネルをリストに変換するので同じようなことができます。'
  close:
    'Go の組み込み関数 <code>close</code> はチャネルにこれ以上値が送られないことをマークします。
    <code>close</code> を Haskell で簡単に再現するには <code>Maybe</code> を使い、
    最後の値として <code>Nothing</code> を送るようにすればよいでしょう。
    ただしこれはごく簡単な方法なので、すでに <code>Nothing</code>
    を送ったチャネルに更に値が送られたときエラーを起こすことはできません。
    そこは少し注意が必要です。'
  list:
    '余談ですが、Haskell では右のサンプルコードのようなことがやりたいときにはリストを使う方が素直な書き方になるでしょう。
    リスト版も載せておきます。'

select:
  first: ""
